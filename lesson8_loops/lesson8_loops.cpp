#include <iostream>

int main() {
    // Агрегационными функциями или агрегаторами называют выражения,
    //  которые из множества делают одно число - максимум, мин, среднее, сумма, ....

    // Задача: пользователь вводит число Х, необходимо найти сумму всех чисел
    //  от 1 до Х (не включительно): 1 + 2 + ... + X-1   (сам Х не прибавляем)
    unsigned short x;   // вводимое число
    unsigned long sum;  // сумма (переменная-аккумулятор, накапливающая сумму)
    std::cout << "Enter x = ";
    std::cin >> x;

    sum = 0;
    for (unsigned short i = 1; i < x; ++i) {
        sum += i;  // аккумулирование - добавление меняющегося числа "i"
    }
    std::cout << "Sum = " << sum;

    // x = 4
    // i    sum
    // 1     0        // начало цикла
    // 1     1        // первая итерация - тело цикла (sum += i)
    // 2     1        // начало второй итерации
    // 2     3        // вторая итерация - тело цикла (sum += i)
    // 3     3
    // 3     6
    // 4 - конец цикла, условие не проходит

    return 0;
}

int main2() {
    // Задание: пользователь вводит число Х, выводятся все числа от 0 до Х
    // Анализ: 0 указан как предел, Х непонятно - включительно или нет.
    //  Принимаем решение - включительно
    int x;
    std::cout << "Enter x = ";
    std::cin >> x;
    for (int i = 0; i <= x; i++) {
        std::cout << i << std::endl;
    }

    std::cout << "------------------------------------------\n";

    // Испытание: для положительных чисел работает, для отрицательных - нет
    // Решение 1: разделение условным оператором
    if (x >= 0) {
        for (int i = 0; i <= x; i++) {   // переменная i может использоваться
            std::cout << i << std::endl; // снова, т.к. старая уже разрушена
        }
    }
    else {
        for (int i = 0; i >= x; i--) {
            std::cout << i << std::endl;
        }
    }
    // Недостаток решения - много повторяющегося кода (DRY)
    
    std::cout << "------------------------------------------\n";

    // Решение 2: с одним циклом
    for (int i = 0; 
        i != x; 
        i += (x > 0) ? 1 : -1)  // тернарное выражение позволяет разделить + и -
    {
        std::cout << i << std::endl;
    } // т.к. мы изменили условие на i != x, сам x надо вывести отдельно
    std::cout << x << std::endl;
    // Чуть лучше, но все равно есть копирование тела цикла

    std::cout << "------------------------------------------\n";

    // Решение 3: В чем проблема решения 2? i != x исключило сам х. 
    // Вариант улучшения сравнивать i != x + 1 / x - 1
    // 
    //                                        // x = 3           | x = -3
    // новая переменная для сокращения записи //                 | 
    int dx = (x > 0) ? 1 : -1;                // dx = 1          | dx = -1
    for(int i = 0; i != x + dx; i += dx) {    // (i=0;i!=4;i+=1) | (i=0;i!=-4;i+=-1)
        std::cout << i << std::endl;          //                 | 
    }                                         

    return 0;
}

int main1()
{
    std::cout << "Loops\n";
    // Вывести числа от 1 до 10 на экран
    // Анализ: из условия понятно сколько раз будет повторяться цикл,
    //  поэтому лучше использовать цикл-счетчик
    int i;  // цикловая переменная (i - iteration)
    for (                 // Оператор цикла. В нем три параметра через ";"
        i = 1;            // - начальное присвоение, выполняется один раз
        i <= 10;          // - цикловое условие: пока true цикл повторяется
        i++               // - правило изменения цикловой переменной.
    ) {                   // Начало тела цикла
        std::cout         // 
            << i          // обращение к цикловой переменной. На каждой
            << std::endl; //  итерации она имеет новое значение
    }                     // Конец тела цикла

    std::cout << "------------------------------------------\n";

    // Задача: вывести числа от 10 до 1
    for (                 // Новый цикл, со старым никакой связи
        short j = 10;     // локальная переменная - существует только в цикле
        j > 0;            // 
        --j               // префиксная форма декремента
    )                     // 
        std::cout         // В теле цикла один оператор, тогда {} не 
        << j              //   являются обязательными (хотя рекомендуются)
        << std::endl;     // 
                          // Конец цикла, j больше не существует

    std::cout << "------------------------------------------\n";
    
    // Задача: вывести 10 степеней двойки (1 - 2 - 4 - 8 - 16 - 32 ...)
    unsigned short pow2 = 1;  // степени двойки, начальное значение (2^0)
    for (char k = 0; k < 10; k += 1) {  // k - только для организации цикла      
        std::cout << pow2 << std::endl; //  в теле цикла k не используется
        pow2 *= 2;  // с каждым повтором умножаем на 2
    }
    return 0;
}

/*
 Циклы.
 Инструкции для повторного (многократного) выполнения некоторого кода.
 Код, который повторяется, называется телом цикла.
 Сам повтор - итерацией

 В С++ циклы делят на две группы: 
 - цикл-счетчик
 - условный цикл
   = цикл с пред-условием
   = цикл с пост-условием

 Цикл-счетчик повторяется заданное кол-во раз.
 Условный цикл - по результату проверки условия.
*/

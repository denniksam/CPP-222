#include <iostream>
#include <time.h>

// про ДЗ (1-2) : index_of(arr, num) => если число num есть в массиве, то
//  возвращается его индекс, если нет, то возврат (-1)
// ДЗ (2) для бинарного поиска массив должен быть упорядочен (перед проверкой
//  не забыть вызвать sort)
// ДЗ (3) двоичное число - строка с его представлением: "10010101"


// заполнить массив случайными числами
void fill_random(int ar[], size_t size) {  // В С++ по имени массива нельзя узнать его размер, 
                                           // поэтому вторым параметром его передают в функцию
    for (size_t i = 0; i < size; i++) {
        ar[i] = rand() % 21 - 10;
    }
}

// вывести массив на экран
void print_array(int ar[], size_t size) {
    for (size_t i = 0; i < size; i++)
    {
        std::cout << ar[i] << ' ';
    }
    std::cout << std::endl;
}

// упорядочить (сортировать) массив
void sort_array(int ar[], size_t size) {
    // sort | order by - расположить элементы массива в порядке 
    // возрастания (ascending, asc) или убывания (descending, desc) их значений
    // Основным моментом является перестановка элементов, если они стоят
    //  не в нужном порядке
    size_t i, j;
    for (i = 0; i < size - 1; ++i) {
        for (j = i + 1; j < size; ++j) {
            if (ar[i] > ar[j]) {   // неправильный порядок - меняем местами
                int tmp = ar[i];
                ar[i] = ar[j];
                ar[j] = tmp;
            }
        }
    }
    /* i = 1;
    for (j = 2; j < size; ++j) {
        if (ar[i] > ar[j]) {   // неправильный порядок - меняем местами
            int tmp = ar[i];
            ar[i] = ar[j];
            ar[j] = tmp;
        }
    }
    i = 2;
    for (j = 3; j < size; ++j) {
        if (ar[i] > ar[j]) {   // неправильный порядок - меняем местами
            int tmp = ar[i];
            ar[i] = ar[j];
            ar[j] = tmp;
        }
    }*/
}

// написать функцию sort_array_desc сортирующую по убыванию
void sort_array_desc(int ar[], size_t size) {
    size_t i, j;
    for (i = 0; i < size - 1; ++i) {
        for (j = i + 1; j < size; ++j) {
            if (ar[i] < ar[j]) {  // изменения здесь - другое сравнение
                int tmp = ar[i];
                ar[i] = ar[j];
                ar[j] = tmp;
            }
        }
    }
}

void sort_array2(int ar[], size_t size) {
    // выполняем перестановки если это нужно
    size_t i, j;
    bool need_restart;
    do {
        need_restart = false;
        for (i = 0; i < size - 1; ++i) {  // проходим массив 
            j = i + 1;                    // и сравниваем два соседних эл-та
            if (ar[i] > ar[j]) {  
                int tmp = ar[i];
                ar[i] = ar[j];
                ar[j] = tmp;
                need_restart = true;      // если была перестановка - нужно повторить
            }
        }
    } while (need_restart);
}

int main() {
    const size_t N = 10;
    int arr[N];

    // заполнить массив случайными числами
    srand(time(NULL));
    fill_random(arr, N);

    // вывести массив на экран
    print_array(arr, N);

    // сортировка
    sort_array2(arr, N);

    // вывод
    print_array(arr, N);


    return 0;
}


// функция, увеличивающая число на 1
int inc(int x) {
    return ++x;
}

// функция, увеличивающая на 1 первый (0) элемент массива
int inc0(int arr[]) {
    return ++arr[0];
}

int main2()
{
    int x = 10;
    inc(x);
    std::cout << x;  // 10, в функции увеличивается другой х
    std::cout << std::endl;

    int arr[3] = { 1, 2, 3 };
    inc0(arr);
    std::cout << arr[0]   // 2, изменения вносятся в массив
        << std::endl;

    return 0;
}

/* Функции, часть 2 - работа с массивами
  int inc0(int arr[]) {  // область параметров: имя - arr, тип - указатель на int
    return ++arr[0];     //  значение при вызове - arr=100, форма - копия
    arr += 1;            // это меняет копию, в точке вызова изменений нет
  }                      // НО arr[0] - это значение, находящееся по адресу 100
                         //  поэтому поменяется элемент массива (не копия)
  main()
  {                                               val:  .. .. [1] [2] [3] ...  
     int arr[3] = { 1, 2, 3 };                   addr:  FE FF 100 101 102 103 
     // arr - 100; arr[0] - 1
     inc0(arr);
  }

  !! Изменения, внесенные в массив внутри тела функции, будут внесены в
     исходный массив и отразятся во всей программе. Такое поведение
     называется побочным эффектом (side effect).
     + не нужно копировать данные
     + можно использовать для возврата нескольких данных из функции
     - возможные искажения данных
*/

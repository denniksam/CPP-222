#include <iostream>
#include <bitset>

// условная компиляция - включение или исключение из программы блоков кода
// 1. Определяем (или не определяем) литерал
#define USE_BITWISE
// #define USE_DOUBLE
#include "header.h"


int main() {
    short y = 52;
    if( IS_ODD(y) ) {  // будет заменено препроцессором на if( (y & 1) ) {...
        std::cout << y << " ODD";
    }
    else {
        std::cout << y << " EVEN";
    }
    return 0;
}

/// <summary>
/// Точка входа в приложение
/// </summary>
/// <param name="argc">Количество аргументов</param>
/// <param name="argv">Значения аргументов</param>
/// <returns>Код завершения</returns>
int main1(int argc, char** argv)
{
    unsigned short x, y, w;
    x = 5;
    y = 12;
    w = x & y;  // AND
    std::cout << x << " AND " << y << " = " << w << std::endl;
    std::cout << 
        std::bitset<4>(x) << " AND" << std::endl <<
        std::bitset<4>(y) << " =  " << std::endl <<
        std::bitset<4>(w) << std::endl;

    w = x | y;  // OR
    std::cout << x << " OR " << y << " = " << w << std::endl;
    std::cout <<
        std::bitset<4>(x) << " OR" << std::endl <<
        std::bitset<4>(y) << " =  " << std::endl <<
        std::bitset<4>(w) << std::endl;

    w = x ^ y;  // XOR
    std::cout << x << " XOR " << y << " = " << w << std::endl;
    std::cout <<
        std::bitset<4>(x) << " XOR" << std::endl <<
        std::bitset<4>(y) << " =  " << std::endl <<
        std::bitset<4>(w) << std::endl;

    w = ~x;
    std::cout << "NOT " << x << " = " << w << std::endl;
    std::cout <<
        std::bitset<4>(x) << " NOT" << std::endl <<
        std::bitset<4>(w) << std::endl;

    w = x >> 1;  // битовый сдвиг вправо на 1 позицию
    std::cout << "SHR " << x << " = " << w << std::endl;
    std::cout <<
        std::bitset<4>(x) << " SHR" << std::endl <<
        std::bitset<4>(w) << std::endl;

    w = x << 1;  // битовый сдвиг влево на 1 позицию
    std::cout << "SHL " << x << " = " << w << std::endl;
    std::cout <<
        std::bitset<4>(x) << " SHL" << std::endl <<
        std::bitset<4>(w) << std::endl;

    return 0;
}
/*
    Битовые (bitwise) операции - операции, выполняемые побитно, то есть 
    каждый бит - с каждым
    Бинарная запись числа
    123  = 3*10^0  +  2*10^1  +  1*10^2    Позиционная система исчисления - 
    0101 = 1*2^0 + 0*2^1 + 1*2^2 + 0*2^3    позиция цифры отвечает за "степень"

    1  1 (2^0)         10101  = 1 + 4 + 16 = 21
    0  2 (2^1)
    1  4 (2^2)
    0  8 (2^3)
    1  16 (2^4)


 (5)   0101      0 1 0 1           При битовых операциях считаются раздельно
 (12)  1100  =>  1 1 0 0           результаты каждой пары бит (a,b,c,d)  и
       -----     - - - -           из них составляется одно число abcd
                 a b c d

    Операции: AND, OR, XOR, NOT
    Таблицы истинности - "паспорт" операции
      (x AND y)  (x & y)  логическое "умножение" - конъюнкция
      x\y | 0  1       0 1 0 1      0101 AND 1100 = 0100
      ----|------      1 1 0 0        5  AND  12  =  4
      0   | 0  0       - - - -
      1   | 0  1       0 1 0 0

      (x OR y)  (x | y)             8421    8421   8421
      x\y | 0  1       0 1 0 1      0101 OR 1100 = 1101
      ----|------      1 1 0 0        5  OR  12  =  13
      0   | 0  1       - - - -
      1   | 1  1       1 1 0 1

      (x XOR y)  (x ^ y)  eXclusive OR (ИЛИ-ИЛИ)
      x\y | 0  1       0 1 0 1      0101 XOR 1100 = 1001
      ----|------      1 1 0 0        5  XOR  12  =  9
      0   | 0  1       - - - -
      1   | 1  0       1 0 0 1

      Унарные операции - действуют на один аргумент
      NOT x (~x) - все биты меняются на противоположные
      NOT 0101 = 1010

      Битовый сдвиг (вправо, влево, циклический)
      SHR 0101 = 0010[1->]    (Shift Right)
      SHL 0101 = [<-0]1010

      Применение:
      Эти операции очень быстрые
      - проверить число на четность: 
          x % 2 - деление, медленная операция
          x & 1 - битовая, быстрая: (любое четное) & 1 == 0
      - умножить число на 2
          х * 2 - арифметика, медленная
          x << 1 - битовый сдвиг, быстрый
      - поделить на 2 (нацело)
          x / 2 - медленно
          x >> 1 - быстро
      - остаток от деления на 4, 8, 16, .... (на 2 - см. п.1)
          x & (N-1) :  x & 7   x & 15

          1000101101010 (x)
          0000000001111 (15)
          ------------------- &
          0000000001010

Директивы препроцессора
Препроцессор - обработчик кода как текста до компиляции
Можно сказать, что препроцессор собирает все файлы проекта в один
 и потом результат сборки передает на компиляцию
Директивы начинаются символом #, занимают всю строку, не требуют ";"
#include <file> -- подключить (скопировать содержимое) file из библиотеки в наш проект
#include "file" -- то же самое, но файл берется из папки проекта
#define F R     -- поиск и замена: находится F, заменяется на R
#define F  -- создание "определенного литерала F", в дальнейшем можно проверить
              определен или нет к-л литерал.
#pragma -- расширенные команды, зависят от компилятора
 #pragma startup  -- поменять точку входа (вместо main)
 #pragma once     -- однократное подключение файла (первый #include работает, остальные нет)
*/

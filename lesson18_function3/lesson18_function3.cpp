#include <iostream>

void say_hello(std::string);  // forward declaration - только имя, без тела
void say_hello(std::string str, int n);

void print_string(std::string str, int n = 1) {
    for (int i = 0; i < n; ++i) {
        std::cout << str;
    }
}
/* Нельзя - неоднозначность при 
   вызове print_string("The String\n");
void print_string(std::string str) {
    std::cout << str;
}
*/

// вывести числа от n до 1 (рекурсия, не используем циклы)
void print(int n) {
    // обязательное условие выхода
    if (n == 0) return;

    // действие
    std::cout << n << ' ';

    // рекурсивный вызов С ИЗМЕНЕННЫМИ аргументами
    print(n - 1);
}

// вывести числа от 1 до n (рекурсия, не используем циклы)
void print_1(int n) {
    // обязательное условие выхода
    if (n == 0) return;

    // рекурсивный вызов С ИЗМЕНЕННЫМИ аргументами
    print_1(n - 1);

    // действие
    std::cout << n << ' ';
}

// числа Фибоначчи
int fib(int n) {
    if (n < 3) return 1;  // n == 1 || n == 2
    return fib(n - 1) + fib(n - 2);
}

int main()
{
    for (int i = 1; i < 50; ++i) {
        std::cout << i << ' ' << fib(i) << std::endl;
    }

    print(10);
    std::cout << std::endl;
    print_1(10);
    std::cout << std::endl;

    say_hello("Hello World!\n");
    say_hello("Hello World!\n", 3);

    print_string("The String\n");   // n не передаем - по умолчанию n=1
    print_string("The String\n", 3);
}

// один раз вывести строку
void say_hello(std::string str) {
    std::cout << str;
}

// n раз вывести строку
void say_hello(std::string str, int n) {
    for (int i = 0; i < n; ++i) {
        std::cout << str;
    }
}

/* Функции, часть 3: перегрузка, рекурсия

Предварительное объявление (forward declaration) или прототип
 Hoisting - поднятие определений - перенос (копирование) всех
 прототипов функций в самое начало программы (файла). Это делает
 все функции доступными в любом месте программы.
 Есть такая традиция - независимо от порядка вызова, прототипы
  всех функций пишут в начале программы

Перегрузка (overload) функций - прием в программировании, 
 при котором создаются несколько функций с одинаковым именем, но
 с разным количеством и/или типом параметров
 !! тип возвращаемого значения не играет роли

Например, нужна функция inv(x) ==> -x
int inv(int x) { return -x; }      | перегрузки 
long inv(long x) { return -x; }    | функции
float inv(float x) { return -x; }  | inv

main() { int x = 1; int y = inv(x); - автоматический выбор (int) } 

Другое название перегрузки - параметрический полиморфизм

Параметры по умолчанию (со значениями по умолчанию)
!! нельзя смешивать перегрузку и параметры по умолчанию
! параметры по умолчанию должны идти после обычных параметров,
  комбинирование не допускается
  fun(int x, int y=0, int z) - нельзя
  fun(int x, int z, int y=0) - можно
  fun(int x, int y=0, int z=0) - можно

Рекурсия
 Прием в программировании при котором
 а) функция может вызвать саму себя (авто- или саморекурсия)
 б) две функции могут вызывать друг друга (взаимная рекурсия)
Применяется для 
 - вычисления рекуррентных рядов
    например, числа Фибоначчи  Fn = Fn-1 + Fn-2 (F1=F2=1)
    1 1 2 3 5 8 13
 - алгоритмов работы с "деревом"
 - альтернативные парадигмы обработки данных (кортежи)

 Рекурсивная функция должна содержать два момента:
  - обязательное условие выхода
  - рекурсивный вызов С ИЗМЕНЕННЫМИ аргументами

print(4) {
  if(4==0)...
  std::cout << 4
  print(3) {
    if(3==0)...
    std::cout << 3
    print(2) {
      if(2==0)...
      std::cout << 2
      print(1) {
        if(1==0)...
        std::cout << 1
        print(0) {
          if(0==0) return ;
        }
      }
    }
  }
}

print_1(4) {
  if(4==0)...  
  print_1(3) {
    if(3==0)...
    print_1(2) {
      if(2==0)...
      print_1(1) {
        if(1==0)...
        print_1(0) {
          if(0==0) return ;
        }
        std::cout << 1
      }
      std::cout << 2
    }
    std::cout << 3
  }
  std::cout << 4
}
    
      

*/
#include <iostream>

typedef int var_type ;   // псевдоним для типа данных

void fill_arr(int* arr, size_t length) {
    for (size_t i = 0; i < length; i++) {
        *(arr + i) = i + 1;
    }
}

void print_arr(int* arr, size_t length) {
    for (size_t i = 0; i < length; i++) {
        std::cout << *(arr + i) << " ";
    }
    std::cout << std::endl;
}

int main() {
    size_t n = 10;
    int* arr = new int[n];
    fill_arr(arr, n);
    print_arr(arr, n);
    delete[] arr;

    return 0;
}

int main1()
{
    var_type x;    // переменная "х"
    var_type* px;  // указатель на объект типа int (предполагается на х)
    x = 10;        // присваивание - копирование 10 в память "х"
    px = &x;       // & - получение адреса, рх получает адрес переменной "х"
    *px = 20;      // запись по адресу рх - то же самое, что х = 20
    
    std::cout << px << ' ' << *px << ' ' << px[0] << std::endl;
    std::cout << (px + 1) << ' ' << px + 2 << std::endl;
    std::cout << px - 1 << ' ' << px - 2 << std::endl;

    // указатели позволяют создавать переменные (выделять память)
    // во время работы программы

    var_type* py;       // только указатель, самой переменной "у" нет
    py = new var_type;  // резервирование памяти в "куче" (heap) - за программой
    *py = 30;           // запись в ячейку "у"
    std::cout << py << ' ' << *py << std::endl;

    // еще бОльшая экономия на массивах - в стеке хранится только
    // один указатель, а все элементы массива создаются в куче и
    // разыменовываются со смещением

    var_type* arr;           // указатель - на начало массива (на первый эл-т)
    size_t n = 10;           // переменная (не константа)
    arr = new var_type[n];   // выделение памяти под массив, а размер - переменная
    for (size_t i = 0; i < n; i++) {
        arr[i] = i + 1;      // разыменование со смещением - как в массиве
    }
    for (size_t i = 0; i < n; i++) {
        std::cout            // 
            << *(arr + i)    // прямое разыменование смещенного указателя
            << ' ';          // *(arr + i) то же самое arr[i]
    }
    std::cout << std::endl;

    // освобождение памяти - каждый оператор new должен быть освобожден
    // оператором delete
    delete py;     // удаление одного объекта (переменной)
    delete[] arr;  // удаление массива
    // !! память свободна, но значения указателей не обнулились и
    //    данные из памяти не стерты

    arr = new var_type[10];  // выделена память 10 ячеек, адрес в arr
    arr = new var_type[10];  // --//-- новый адрес в arr, старый потерян
    // НО первые 10 ячеек закреплены за нашей программой и считаются
    // занятыми, а адрес мы стерли (утратили), значит удалить (освободить)
    // память мы не можем ==> это называется "утечка памяти" 
    // (memory leakage)

    /* Необходимость удалять указатели влияет на стиль программирования
    1) data = make_data();  // new inside function
       print(data);
       delete[] data;  // ?? может просто delete (без [])

    2) data = new int[10];
       fill_arr(data);
       print(data);
       delete[] data;    
    */

    return 0;
}

/*
Указатели (Pointers)
Особый тип данных, хранящий в себе адрес памяти, обычно,
по которому находится другой объект
Размер зависит от режима сборки (разрядности ОС)
Обычно, указатель используется для доступа к данным, 
 поэтому кроме адреса в указатели хранится информация о
 типе данных, на которые он указывает
Разыменование указателя - получение данных, на которые он 
 указывает. Простое разыменование - *, разыменование со смещением - []
Арифметика указателей: к указателю можно добавить или отнять число
 при этом укзатель смещается на количество "ячеек", определяемых
 типом данных указателя
Разыменование со смещением p[n] == *(p+n)  -- смещение указателя + разым.
*/
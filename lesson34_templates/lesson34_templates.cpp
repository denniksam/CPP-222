#include <iostream>

/////////// шаблоны типов /////////////////////
template <typename T>        // Шаблонный тип для "точки" - пары координат (x,y)
struct Point {               // 
    T x;                     // х и у имеют тот тип данных, который будет при реализации
    T y;                     // 
};                           //

template <class T>
std::ostream& operator << (std::ostream& stream, Point<T> point) {
    stream << '(' << point.x << ',' << point.y << ')';
    return stream;
}

int main() {
    std::cout << "Templates!\n";

    Point<int> p1;            // Будут сгенерированны две структуры с соотв. типами
    Point<float> p2;          // полей (х и у)

    p1.x = 10;  p1.y = 20;
    p2.x = 0.1; p2.y = 0.2;

    std::cout << "p1 = "      // Будут сгенерированны два оператора <<
        << p1 << std::endl;   // один для Point<int>
    std::cout << "p2 = "      // другой для Point<float>
        << p2 << std::endl;   // 

    int x = 123;              // переменная
    int* px = &x;             // указатель на переменную - переменная (32/64 бита) с адресом "х"
    std::cout << *px;         // разыменование указателя
    int** ppx = &px;          // указатель на указатель: ppx - адрес памяти, в которой лежит px
                              // "добраться" до рх: *ppx
                              // "добраться" до х через ppx:  **ppx
    std::cout << **ppx;

    return 0;
}

/////////// шаблоны функций /////////////////////

template <typename T>         // Шаблон, Т - сокращения для типа (можно любое имя)
void print(T x) {             // В функции (тип возврата, параметры, внутренние переменные)
    std::cout << x;           // может использоваться "Т" как тип
}                             // template "действует" на ближайшее определение (тут заканчивается)

template <class T> 
auto type_size(T x) -> int {  // Хвостовой возвращаемый тип (trailing-return-type)
    return sizeof(x);         // синтаксис с С++11, более удобный для комплексных типов
}

int main_func()
{
    std::cout << "Templates!\n";
    int a = 10;
    float b = 0.10f;
                              // Компилятор анализирует использование шаблонов
    print(a);                 //  - шаблон для int
    std::cout << std::endl;   // 
    print(b);                 //  - шаблон для float
                              // Нужны два шаблона - будут построены две копии
                              // print<int>(int x)  и  print<float>(float x)

    print(20);                // 20 - int, используется та же реализация print<int>
    print(0.2);               // 0.2 - double, будет построена новая реализация

    short c = 30;
    // print(c);              // нам годится print<int> и мы не хотим новую реализацию
    print<int>(c);            // прямое обращение к реализации

    return 0;
}

/*
    Обобщенное (Generic) программирование. Шаблоны.
    Шаблонными бывают функции и типы (структуры, классы)
    Шаблон - это "заготовка" для создания функции/типа
     компилятор, обнаруживая обращения к шаблонам, определяет все
     типы с которыми эти обращения есть в коде.
     Под каждый тип копируется шаблон и создается новый код (блок)
     В итоге, в коде присутствуют несколько копий шаблона с разными типами,
     тогда как сам шаблон - отсутствует.
*/
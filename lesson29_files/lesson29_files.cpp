#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>

int main() {
    FILE* r = fopen("file1.txt", "rt");
    if (!r) {   // !r   - то же, что и   r == NULL
        std::cout << "File open error!\n";
        return -1;
    }

    char str[100]; 
    while (!feof(r)) {       // EOF - End Of File
        fgets(str, 100, r);  // get string - берет строку (до \n) из файла (но не более 100 символов)
        std::cout << str;
    }
   
    fclose(r);
    return  0;
}

struct Complex {
    float re;
    float im;
};

int main4() {
    // десериализация - восстановление данных
    Complex* arr = new Complex[10];
    FILE* f = fopen("complex.dat", "r");
    if (!f) {
        std::cout << "File open error";
        return -1;
    }
    fread(arr, sizeof(Complex), 10, f);
    fclose(f);
    for (int i = 0; i < 10; i++) {
        std::cout << arr[i].re << " " << arr[i].im << std::endl;
    }
    delete[] arr;
    return 0;
}

int main3() {
    // а-ля сериализация -- запись в файл структур или их массивов
    Complex* arr = new Complex[10];
    for (int i = 0; i < 10; i++) {
        arr[i].re = i + 1;
        arr[i].im = i + 101;
    }
    FILE* f = fopen("complex.dat", "w");
    fwrite(arr, sizeof(Complex), 10, f);
    fflush(f);
    fclose(f);
    std::cout << "Danone";
    delete[] arr;
    return 0;
}

int main2() {  // чтение файла
    FILE* r;  // тип для чтения - такой же
    r = fopen("file1.txt", "rt");
    if (!r) {   // !r   - то же, что и   r == NULL
        std::cout << "File open error!\n";
        return -1;
    }
    // чтение из файла
    char str[100];
    fgets(str, 100, r);  // get string - берет строку (до \n) из файла (но не более 100 символов)

    std::cout << str << std::endl;

    int x;
    fread(&x, sizeof(x), 1, r);  // прямое копирование из файла в память (&х)
    std::cout << x << std::endl;

    fclose(r);
    return 0;
}

int main1()  // запись файла
{
    FILE* f;             // файловая переменная - для обмена данными с файлом
    f = fopen(           // команда открытия файла (запрос, попытка открытия)
        "file1.txt",     // имя файла
        "wt"             // режим открытия (запись, текст) !! открытие на запись
    );                   // ! создает файл, если его нет, или стирает, если есть
    if (f == NULL) {     // после попытки открытия ОБЯЗАТЕЛЬНО проверить успешность
        std::cout <<     // 
            "File open error!\n";
        return -1;
    }
    std::cout << "File was opened\n";

    fputs("Hello, world! ", f);    // запись строки в файл (\r\n - стандарт разрыва строки)
    fprintf(f, "num = %d\n", 20);  // форматированный вывод в файл
    
    int x = 123;
    fwrite(&x, sizeof(x), 1, f);   // "низкоуровневая" запись - из памяти в файл
    
    fflush(f);                     // когда всё на запись отправлено, сбрасываем буфер (на диск)

    fclose(f);           // закрываем файл - освобождаем системный ресурс
    return 0;
}
/*
    Файлы
    Работа с файлами обычно имеет два аспекта:
    - хранение данных в файлах (и работа с данными)
    - организация файлов или работа с файловой системой

    Часть 1. Работа с данными в файлах
    Файл - именованная совокупность данных
    Хранение файла и работа с ним
    файл хранится на носителе 
     программа дает запрос операционной системе на открытие файла
      |
      система а) не может открыть файл и возвращает ошибку
              б) находит файл, создает для него буфер обмена,
                 "помечает" файл как открытый (блокирует его)
                 передает программе указатель на открытый буфер
      |
     данные используются в программе

   ОС может открыть файл в одном из режимов:
    с т.з. направления       с т.з. кодирования      с т.з. начальной позиции
      чтение r                 текстовый t              с начала файла  -
      запись w                 бинарный  b              с конца файла   a
      обновление +

    например:   "rt" - для чтения в текстовом виде с начала файла
                "wb" - для записи в бинарном режиме
                "a+" - для обновления (и чтение, и запись) с дописью в конец
*/
